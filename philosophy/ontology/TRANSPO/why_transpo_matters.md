Let's say you try to represent a Cat and you start with something like this:

Cat has_FurType

###### Observation
But look, your instance of Cat has_FurType when actually we know a Cat cant have a general `FurType` but can only have a `CatFurType` since it is a Cat. 

###### Realization
When we fully expand *what ontology engineering is*, isn't it, itself, a meta-language that has templated patterns (ie criteria for applying relationships as edges between nodes) that are always the same and always indicate the same things and the differentiator between all the truth values is simply semantic as long as those patterns are satisfied? Otherwise, we have multiple layers of problems because we can say things that SOUND RIGHT but when expanded have ontological issues.
